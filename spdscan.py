import numpy as np

def spdbscan(seg, Sp, Am, Ec):
    '''  l   - Labeled image of clusters/regions generated by a superpixel
               algorithm,  such as  SLIC. 
         Cp  - 5 x Np array, as returned by SLIC. Each column giving the
               attributes of each superpixel region.  Only the first 3
               attributes, the Lab colour values, are used. 
         Am  - An adjacency matrix of the labeled image (also returned by SLIC).
         E   - Matching tolerance value/distance threshold that controls which
               superpixels are clustered together.  This value is in L*a*b*
               colour units.  Try a value in the range 5-10 to start with.
               Changing the value of E by just 1 unit can give a significant
               difference.'''
             
    Np = np.amax(seg)
    regionsC = [-1 for _ in range(Np+1)]
    Nc = -1
    Pvisit = [-1 for _ in range(Np+1)]
    
    for n in range(0, Np):
        # If this neighbour has not been visited mark it as visited.
        if Pvisit[n] == -1:
            Pvisit[n] = 1   
            neighbours = regionQuery(Sp, Am, n, Ec)
            # Increment number of clusters and process neighbourhood.
            Nc = Nc+1
            # Initialise cluster Nc with point n and mark superpixel n as being a member of cluster Nc.
            regionsC[n] = Nc
            # Initialise index into neighbourPts array.
            ind = 1
            
            while ind <= len(neighbours):
                nb = neighbours[ind-1]                    
                # If this neighbour has not been visited mark it as visited.
                if Pvisit[nb] == -1:
                    Pvisit[nb] = 1
                    # Find the neighbours of this neighbour and add them to the neighbours list.
                    neighboursP = regionQuery(Sp, Am, nb, Ec)
                    neighbours = np.hstack((neighbours,neighboursP))
                # If this neighbour nb not yet a member of any cluster add it to this cluster.
                if regionsC[nb] == -1:
                    regionsC[nb] = Nc      
                # Increment neighbour point index and process next neighbour.    
                ind = ind + 1       
    lc = seg*0
    for n in range(0, len(regionsC)):
        lc[seg==n] = regionsC[n]
            
    return lc
    '''lc - New labeled image corresponding to the new clustered regions of superpixels.'''
    
def regionQuery(Sp, Am, n, Ec):
    
    E2 = Ec**2
    neighbours = np.array([], dtype=np.uint16)
    
    dum, ind = Am[n,:].nonzero()
    
    # If the color space distance value of the adjacent superpixel is smaller than the input value, the merge is performed.
    for i in range(0, len(ind)):
        dist2 = (Sp[0][ind[i]]-Sp[0][n])**2+(Sp[1][ind[i]]-Sp[1][n])**2+(Sp[2][ind[i]]-Sp[2][n])**2
        if dist2 < E2:
            neighbours = np.hstack((neighbours,ind[i]))
            
    return neighbours


def maxLabel(lc, img):
    
    i=0
    k = np.array([], dtype=np.uint16)
    while i <= np.amax(lc):
        temp = sum(sum(lc[:]==i))
        k = np.hstack((k, temp))
        i=i+1
        
    tempArray = k.ravel().argsort()[::-1]
    
    imSize = np.size(lc)
    # Only takes more than 10% of the image size.
    imSize5 = round(imSize/10)
    
    mxlb = np.array([], dtype=np.uint16)
    tempIm = lc*0
    mxIm={}
    mxLc={}
    
    i=0
    while k[tempArray[i]] > imSize5:
        mxlb = np.hstack((mxlb, k[tempArray[i]])) 
        tempIm = (lc[:]==tempArray[i])
        mxLc[i] = (lc[:]==tempArray[i])
        mxImg = img*0
        mxImg[:,:,0] = img[:,:,0] * tempIm
        mxImg[:,:,1] = img[:,:,1] * tempIm
        mxImg[:,:,2] = img[:,:,2] * tempIm
        mxIm[i]=mxImg
        i=i+1

    return mxIm, mxLc